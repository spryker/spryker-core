{% import 'macros.php.twig' as macro %}
<?php

/**
 * (c) Spryker Systems GmbH copyright protected
 */

namespace Generated\Shared\Transfer;

{% for useStatement in useStatements %}
use {{ useStatement }};
{% endfor %}
use Spryker\Shared\Kernel\Transfer\AbstractTransfer;
{% if entityNamespace is null %}
{% set abstractClass = 'AbstractTransfer' %}
{% set isEntityTransfer = false %}
{% else %}
use Spryker\Shared\Kernel\Transfer\AbstractEntityTransfer;
{% set abstractClass = 'AbstractEntityTransfer' %}
{% set isEntityTransfer = true %}
{% endif %}

/**
 * !!! THIS FILE IS AUTO-GENERATED, EVERY CHANGE WILL BE LOST WITH THE NEXT RUN OF TRANSFER GENERATOR
 * !!! DO NOT CHANGE ANYTHING IN THIS FILE
 {% if deprecationDescription is not null -%}
 *
 * @deprecated {{ deprecationDescription }}
 {% endif -%}
 */
class {{ className }} extends {{ abstractClass }}
{
{% for constant in constants %}
{{ macro.addConstant(constant) -}}
{% endfor %}
{% for property in properties %}
{{ macro.addProperty(property) }}
{% endfor -%}
{% if isDebugMode %}
    /**
     * @var \Monolog\Logger|null
     */
    protected $logger;

{% endif %}
{{ macro.addPropertyNameMap(propertyNameMap) }}

{{ macro.addMetadata(normalizedProperties) }}
{% if entityNamespace is not null -%}
{{ macro.addEntityNamespace(entityNamespace) }}
{% endif -%}
{{ macro.addConstructor(constructorDefinition) -}}
{% for methodName, method  in methods %}

{% if methodName starts with 'set' %}
{{ macro.addSet(method) -}}
{% endif %}
{% if methodName starts with 'get' %}
{{ macro.addGet(method) -}}
{% endif %}
{% if methodName starts with 'add' %}
{% if not method.is_associative %}
{{ macro.addAdd(method) -}}
{% else %}
{{ macro.addAssociative(method) -}}
{% endif %}
{% endif %}
{% if methodName starts with 'require' %}
{{ macro.addRequire(method) -}}
{% endif %}
{% endfor %}

    /**
     * @param array $data
     * @param bool $ignoreMissingProperty
     * @return {{ className }}
     */
    public function fromArray(array $data, $ignoreMissingProperty = false)
    {
        foreach ($data as $property => $value) {
            $normalizedPropertyName = $this->transferPropertyNameMap[$property] ?? null;
{% if isDebugMode %}

            if ($normalizedPropertyName !== null) {
                $this->validateFromArrayValueType($normalizedPropertyName, $value);
            }
{% endif %}

            switch ($normalizedPropertyName) {
{% if primitives is not empty %}
{% for value in primitives %}
                case '{{ value.name }}':
{% endfor %}
                    $this->$normalizedPropertyName = $value;
                    $this->modifiedProperties[$normalizedPropertyName] = true;
                    break;
{% endif %}
{% if transfers is not empty %}
{% for value in transfers %}
                case '{{ value.name }}':
{% endfor %}
                    if (is_array($value)) {
                        $type = $this->transferMetadata[$normalizedPropertyName]['type'];
                        /** @var \Spryker\Shared\Kernel\Transfer\TransferInterface $transferObject */
                        $value = (new $type())->fromArray($value, $ignoreMissingProperty);
                    }
                    $this->$normalizedPropertyName = $value;
                    $this->modifiedProperties[$normalizedPropertyName] = true;

                    break;
{% endif %}
{% if transferCollections is not empty %}
{% for value in transferCollections %}
                case '{{ value.name }}':
{% endfor %}
                    $elementType = $this->transferMetadata[$normalizedPropertyName]['type'];
                    $this->$normalizedPropertyName = $this->processArrayObject($elementType, $value, $ignoreMissingProperty);
                    $this->modifiedProperties[$normalizedPropertyName] = true;
                    break;
{% endif %}
{% if valueObjects is not empty %}
    {% for value in valueObjects %}
            case '{{ value.name }}':
    {% endfor %}
                $this->assignValueObject($normalizedPropertyName, $value);
                    break;
{% endif %}
                default:
                    if (!$ignoreMissingProperty) {
                        throw new \InvalidArgumentException(sprintf('Missing property `%s` in `%s`', $property, static::class));
                    }
{% if isEntityTransfer %}
                    $this->virtualProperties[$property] = $value;
{% endif %}
            }
        }

        return $this;
    }

    /**
    * @param bool $isRecursive
    * @param bool $camelCasedKeys
    * @return array
    */
    public function modifiedToArray($isRecursive = true, $camelCasedKeys = false)
    {
        if ($isRecursive && !$camelCasedKeys) {
            return $this->modifiedToArrayRecursiveNotCamelCased();
        }
        if ($isRecursive && $camelCasedKeys) {
            return $this->modifiedToArrayRecursiveCamelCased();
        }
        if (!$isRecursive && $camelCasedKeys) {
            return $this->modifiedToArrayNotRecursiveCamelCased();
        }
        if (!$isRecursive && !$camelCasedKeys) {
            return $this->modifiedToArrayNotRecursiveNotCamelCased();
        }
    }

    /**
    * @param bool $isRecursive
    * @param bool $camelCasedKeys
    * @return array
    */
    public function toArray($isRecursive = true, $camelCasedKeys = false)
    {
        if ($isRecursive && !$camelCasedKeys) {
            return $this->toArrayRecursiveNotCamelCased();
        }
        if ($isRecursive && $camelCasedKeys) {
            return $this->toArrayRecursiveCamelCased();
        }
        if (!$isRecursive && !$camelCasedKeys) {
            return $this->toArrayNotRecursiveNotCamelCased();
        }
        if (!$isRecursive && $camelCasedKeys) {
            return $this->toArrayNotRecursiveCamelCased();
        }
    }

    /**
    * @param mixed $value
    * @param bool $isRecursive
    * @param bool $camelCasedKeys
    * @return array
    */
    protected function addValuesToCollectionModified($value, $isRecursive, $camelCasedKeys)
    {
        $result = [];
        foreach ($value as $elementKey => $arrayElement) {
            if ($arrayElement instanceof AbstractTransfer) {
                $result[$elementKey] = $arrayElement->modifiedToArray($isRecursive, $camelCasedKeys);
                continue;
            }
            $result[$elementKey] = $arrayElement;
        }

        return $result;
    }

    /**
    * @param mixed $value
    * @param bool $isRecursive
    * @param bool $camelCasedKeys
    * @return array
    */
    protected function addValuesToCollection($value, $isRecursive, $camelCasedKeys)
    {
        $result = [];
        foreach ($value as $elementKey => $arrayElement) {
            if ($arrayElement instanceof AbstractTransfer) {
                $result[$elementKey] = $arrayElement->toArray($isRecursive, $camelCasedKeys);
                continue;
            }
            $result[$elementKey] = $arrayElement;
        }

        return $result;
    }

    {{ macro.addModifiedToArray('modifiedToArrayRecursiveCamelCased', true, true, primitives, transfers, transferCollections, valueObjects) }}

    {{ macro.addModifiedToArray('modifiedToArrayRecursiveNotCamelCased', false, true, primitives, transfers, transferCollections, valueObjects) }}

    {{ macro.addModifiedToArray('modifiedToArrayNotRecursiveNotCamelCased', false, false) }}

    {{ macro.addModifiedToArray('modifiedToArrayNotRecursiveCamelCased', true, false) }}

    {{ macro.addInitCollections(transferCollections) }}

    {{ macro.addToArray('toArrayNotRecursiveCamelCased', false, true, primitives, transfers, transferCollections, valueObjects) }}

    {{ macro.addToArray('toArrayNotRecursiveNotCamelCased', false, false, primitives, transfers, transferCollections, valueObjects) }}

    {{ macro.addToArray('toArrayRecursiveNotCamelCased', true, false, primitives, transfers, transferCollections, valueObjects) }}

    {{ macro.addToArray('toArrayRecursiveCamelCased', true, true, primitives, transfers, transferCollections, valueObjects) }}
{% if isDebugMode %}

    /**
    * @param mixed $value
    * @param string $expectedValueTypes Expected types concatenated with '|' sign.
    *
    * @return bool
    */
    protected function checkValueTypeIsCorrect($value, string $expectedValueTypes): bool
    {
        if ($value === null) {
            return true;
        }

        $valueTypesCollection = explode('|', $expectedValueTypes);

        foreach ($valueTypesCollection as $valueType) {
            $typeAssertFunction = $this->getTypeAssertFunction($valueType);

            if ($typeAssertFunction($value)) {
                return true;
            }
        }

        return false;
    }

    /**
    * @param string $varType
    *
    * @throws \InvalidArgumentException
    *
    * @return callable
    */
    protected function getTypeAssertFunction(string $varType): callable
    {
        if (preg_match('/^.*\[\]$/', $varType)) {
            return function ($value) use ($varType) {
                return is_array($value) && $this->checkArrayElementsAreOfExpectedType($value, str_replace('[]', '', $varType));
            };
        }

        if (class_exists($varType)) {
            return function ($value) use ($varType) {
                return $value instanceof $varType;
            };
        }

        if ($varType === 'boolean') {
            return 'is_bool';
        }

        $typeAssertFunctionName = 'is_' . $varType;

        if (!function_exists($typeAssertFunctionName)) {
            throw new \InvalidArgumentException(
                sprintf('Variable type `%s` is not resolvable to an existing type assert function.', $varType)
            );
        }

        return $typeAssertFunctionName;
    }

    /**
    * @param array $array
    * @param string $elementType
    *
    * @return bool
    */
    protected function checkArrayElementsAreOfExpectedType(array $array, string $elementType): bool
    {
        $typeAssertFunction = $this->getTypeAssertFunction($elementType);

        foreach ($array as $arrayElement) {
            if (!$typeAssertFunction($arrayElement)) {
                return false;
            }
        }

        return true;
    }

    /**
    * @param string $propertyName
    * @param mixed $value
    *
    * @return void
    */
    protected function validateFromArrayValueType(string $propertyName, $value): void
    {
        $propertyExpectedTypes = $this->getFromArrayPropertyExpectedTypes($propertyName, $value);

        if ($this->checkValueTypeIsCorrect($value, $propertyExpectedTypes)) {
            return;
        }

        $message = sprintf(
            'Value passed to `%s::fromArray()` method under the `%s` key is expected to be of type(s) %s. %s is given',
            static::class,
            $propertyName,
            $propertyExpectedTypes,
            $this->getActualValueType($value)
        );
        $this->logTypeErrorMessage($message, 2);
    }

    /**
    * @param mixed $value
    * @param string $propertyExpectedTypes
    * @param string $fullyQualifiedCalleeMethodName
    *
    * @return void
    */
    protected function validateAddSetValueType($value, string $propertyExpectedTypes, string $fullyQualifiedCalleeMethodName): void
    {
        if ($this->checkValueTypeIsCorrect($value, $propertyExpectedTypes)) {
            return;
        }

        $message = sprintf(
            'Value passed to `%s()` method is expected to be of type(s) %s. %s is given',
            $fullyQualifiedCalleeMethodName,
            $propertyExpectedTypes,
            $this->getActualValueType($value)
        );
        $this->logTypeErrorMessage($message, 2);
    }

    /**
    * @param mixed $value
    *
    * @return string
    */
    protected function getActualValueType($value): string
    {
        if (!is_array($value)) {
            return gettype($value);
        }

        if (empty($value)) {
            return 'array';
        }

        $firstElementKey = key($value);
        $firstElementType = gettype($value[$firstElementKey]);

        return $this->checkArrayElementsAreOfExpectedType($value, $firstElementType)
            ? $firstElementType . '[]'
            : 'mixed[]';
    }

    /**
    * @param string $message
    *
    * @param int $stackTraceNestingLevel
    *
    * @return void
    */
    protected function logTypeErrorMessage(string $message, $stackTraceNestingLevel = 1): void
    {
        $logger = $this->getLogger();

        if ($logger === null) {
            return;
        }

        ['file' => $callerFileName, 'line' => $callerLineNumber] = debug_backtrace()[$stackTraceNestingLevel];

        $logger->warning(
            sprintf(
                "%s. Called in %s:%d",
                $message,
                $callerFileName,
                $callerLineNumber
            )
        );
        $logger->close();
    }

    /**
    * @return \Monolog\Logger|null
    */
    protected function getLogger(): ?Logger
    {
        if (!$this->isLoggingEnabled()) {
            return null;
        }

        if ($this->logger) {
            return $this->logger;
        }

        $logFilePath = sys_get_temp_dir() . '/transfer-type-error.log';
        $logger = new Logger('transferLogger');
        $logger->pushHandler(
            new DeduplicationHandler(new StreamHandler($logFilePath, Logger::WARNING), null, Logger::WARNING, 120)
        );
        $this->logger = $logger;

        return $this->logger;
    }

    /**
    * @param string $propertyName
    * @param mixed $value
    *
    * @return string
    */
    protected function getFromArrayPropertyExpectedTypes(string $propertyName, $value): string
    {
        $propertyType = $this->transferMetadata[$propertyName]['type'];
        $typeShim = $this->transferMetadata[$propertyName]['type_shim'];

        if ($propertyType === 'array' && is_string($value) && json_decode($value) !== null) {
            $propertyType = 'string';
        }

        if ($this->transferMetadata[$propertyName]['is_transfer']) {
            $propertyType = $this->transferMetadata[$propertyName]['is_collection'] ? '\ArrayObject|array' : 'array';
        }

        if ($typeShim) {
            return sprintf('%s|%s', $propertyType, $typeShim);
        }

        return $propertyType;
    }

    /**
    * @return bool
    */
    protected function isLoggingEnabled(): bool
    {
        return class_exists(\Monolog\Logger::class);
    }
{% endif %}
}
